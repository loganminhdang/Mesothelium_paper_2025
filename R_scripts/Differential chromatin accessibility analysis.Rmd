---
title: "atac_differential_csaw"
output: html_document
date: "2024-11-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(GenomicRanges)
library(csaw)
library(BiocParallel)
library("edgeR")
```

```{r}
setwd('/mnt/sdb/qdang/atac/macs2_peakcalling/run2_652024/q_001')
# starting from MACS2, filtered consensus peaks across all conditions (which I generated using the Corces et al. approach, over all three timepoints, generated from bam files of merged replicates <- it may be better to merge replicates from bam level rather than peak level)

all.peaks <- read.table("merged.filtered.bed", sep="\t")[,1:3]
colnames(all.peaks) <- c("chrom", "start", "end")
all.peaks <- GRanges(all.peaks)
start(all.peaks) <- start(all.peaks) + 1
```
```{r}
setwd('/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library')

pe.bams <- c("E115_REP1.mLb.clN.sorted.bam", "E115_REP2.mLb.clN.sorted.bam","E115_REP3.mLb.clN.sorted.bam",
		     "E135_REP1.mLb.clN.sorted.bam", "E135_REP2.mLb.clN.sorted.bam","E135_REP3.mLb.clN.sorted.bam",
		     "E175_REP1.mLb.clN.sorted.bam", "E175_REP2.mLb.clN.sorted.bam","E175_REP3.mLb.clN.sorted.bam")

# read mm10 blacklist
blacklist <- read.table("/mnt/sdb/qdang/reference/mouse/mm10-blacklist.v2.bed", sep="\t")
colnames(blacklist) <- c("chrom", "start", "end")
blacklist <- GRanges(blacklist)
start(blacklist) <- start(blacklist)+1.

# define read parameters
standard.chr <- paste0("chr", c(1:19, "X", "Y")) # only use standard chromosomes
param <- readParam(max.frag=1000, pe="both", discard=blacklist, restrict=standard.chr)
```


```{r}
##############################
bioc_param <- MulticoreParam(workers = 30)
# count reads in windows specified by MACS2                                      
peak.counts <- regionCounts(pe.bams, all.peaks, param=param, BPPARAM=bioc_param)

##############################
# MACS2 peaks only: filter low abundance peaks
library("edgeR")
peak.abundances <- aveLogCPM(asDGEList(peak.counts)) 
peak.counts.filt <- peak.counts[peak.abundances > -3, ] # only use peaks logCPM > -3
# few or no peaks should be removed; modify as desired
```

```{r}
################No need to run this chunk, it is just for checking the fragment size distribution#####################
setwd('/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library')
# get paired-end fragment size distribution
control1.pe.sizes <- getPESizes("E115_REP1.mLb.clN.sorted.bam")
control2.pe.sizes <- getPESizes("E115_REP2.mLb.clN.sorted.bam")
treat1.pe.sizes <- getPESizes("E135_REP1.mLb.clN.sorted.bam")
treat2.pe.sizes <- getPESizes("E135_REP2.mLb.clN.sorted.bam")
gc()
```

```{r}
#####To retrieve information on fragment sizes, look into the excel file produced by MACS2 peak-alling instead of running the following chunk#####
#options(scipen = 999)
# plot
#hist(treat1.pe.sizes$sizes) # repeat for all replicates and conditions
hist(control1.pe.sizes$sizes)
```

```{r}
setwd('/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library')
##############################
# count BAM reads in, e.g. 300 bp windows
counts <- windowCounts(pe.bams, width=300, param=param, BPPARAM=bioc_param) # set width as desired from the fragment length distribution analyses

# filter uninteresting features (windows) by local enrichment
# local background estimator: 2kb neighborhood
neighbor <- suppressWarnings(resize(rowRanges(counts), width=2000, fix="center")) # change width parameter as desired
wider <- regionCounts(pe.bams, regions=neighbor, param=param) # count reads in neighborhoods
filter.stat <- filterWindowsLocal(counts, wider) 
counts.local.filt <- counts[filter.stat$filter > log2(3),] # threshold of 3-fold increase in enrichment over 2kb neighborhood abundance; change as desired
```

```{r}
###############################
# count BAM background bins (for TMM normalization)
binned <- windowCounts(pe.bams, bin=TRUE, width=10000, param=param, BPPARAM=bioc_param)
```

```{r}
##########################################
# NORMALIZATION (Loess normalization implementation has changed in csaw 1.20.0)

# method 1: MACS2 peaks only, TMM normalization based on binned counts
peak.counts.tmm <- peak.counts.filt
peak.counts.tmm <- normFactors(binned, se.out=peak.counts.tmm)

# method 2: MACS2 peaks only, csaw loess-normalization
peak.counts.loess <- peak.counts.filt
peak.counts.loess <- normOffsets(peak.counts.loess, se.out=TRUE) # type="loess" is now default
# from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."

# method 3: csaw de novo peaks by local enrichment, TMM normalization based on binned counts
counts.local.tmm <- counts.local.filt
counts.local.tmm <- normFactors(binned, se.out=counts.local.tmm)

# method 4: csaw de novo peaks by local enrichment, csaw loess-normalization
counts.local.loess <- counts.local.filt
counts.local.loess <- normOffsets(counts.local.loess, se.out=TRUE) # type="loess" is now default
# from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."
```

```{r}
#########################################
# DIFFERENTIAL ACCESSIBILITY ANALYSIS

#working.windows <- peak.counts.tmm # MACS2 peaks only, standard TMM normalization based on binned counts
#working.windows <- peak.counts.loess # MACS2 peaks only, for trended biases
working.windows <- counts.local.tmm # csaw de novo peaks by local enrichment, standard TMM normalization based on binned counts
#working.windows <- counts.local.loess # csaw de novo peaks by local enrichment, for trended biases
# SEE THE CSAW MANUAL FOR MORE INFO ON NORMALIZATION METHODS
```

```{r}
#set working directory
setwd('/mnt/sdb/qdang/atac/differential/csaw/newrun_22112024/E175vsE135/de_novo_tmm')
# setup design matrix
# see edgeR manual for more information
y <- asDGEList(working.windows)
colnames(y$counts) <- c("E115_REP1", "E115_REP2", "E115_REP3", "E135_REP1", "E135_REP2", "E135_REP3", "E175_REP1", "E175_REP2", "E175_REP3")
rownames(y$samples) <- c("E115_REP1", "E115_REP2", "E115_REP3", "E135_REP1", "E135_REP2", "E135_REP3", "E175_REP1", "E175_REP2", "E175_REP3")
y$samples$group <- c("E115", "E115","E115", "E135", "E135","E135", "E175", "E175","E175")
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- c("E115", "E135", "E175")
# design

# stabilize dispersion estimates with empirical bayes
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)

# testing for differentially-accessible windows
results <- glmQLFTest(fit, contrast=makeContrasts(E175-E135, levels=design))
# head(results$table)

# combine GRanges rowdata with DA statistics
rowData(working.windows) <- cbind(rowData(working.windows), results$table)
working.windows@rowRanges

# merge nearby windows
# up to "tol" distance apart: 500 bp in this case
# max merged window width: 5000 bp
merged.peaks <- mergeWindows(rowRanges(working.windows), tol=500L, max.width=5000L)
# summary(width(merged.peaks$region))
# should merge some peaks; change as desired

# use most significant window as statistical representation for p-value and FDR for merged windows
tab.best <- getBestTest(merged.peaks$id, results$table, pval.col='PValue',cpm.col='logCPM')
head(tab.best)
# combine merged peaks window range with statistics

final.merged.peaks <- GRanges(cbind(as.data.frame(merged.peaks$region), results$table[tab.best$rep.test, -4], tab.best[,-c(7:8)]))

# sort by FDR
final.merged.peaks <- final.merged.peaks[order(final.merged.peaks@elementMetadata$FDR), ]
final.merged.peaks

# filter by FDR threshold
FDR.thresh <- 0.05 # set as desired
final.merged.peaks.sig <- final.merged.peaks[final.merged.peaks@elementMetadata$FDR < FDR.thresh, ]
final.merged.peaks.sig # significant differentially-accessible windows

write.table(final.merged.peaks, "E175_vs_E135_csaw_DA-windows_denovo_tmm_all.txt", sep="\t", quote=F, col.names=T, row.names=F)
write.table(final.merged.peaks.sig, "E175_vs_E135_csaw_DA-windows_denovo_tmm_significant.txt", sep="\t", quote=F, col.names=T, row.names=F)

###########################################

```

```{r}
setwd('/mnt/sdb/qdang/atac/differential/csaw/newrun_22112024/E175vsE135/macs2_tmm')
# Generate MA plot
library(ggplot2)

final.merged.peaks$sig <- "n.s."
final.merged.peaks$sig[final.merged.peaks$FDR < FDR.thresh] <- "significant"

plot <- ggplot(data=data.frame(final.merged.peaks),
       aes(x = logCPM, y = logFC, col = factor(sig, levels=c("n.s.", "significant")))) + 
  geom_point() + scale_color_manual(values = c("black", "red")) + 
  geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + # smoothed loess fit; can add span=0.5 to reduce computation load/time
  geom_hline(yintercept = 0) + labs(col = NULL)

ggsave(plot, filename = "E175_vs_E135_csaw_MAplot_denovo_loess.png", width = 6, height = 6, dpi = 300)
```

```{r}
setwd('/mnt/sdb/qdang/atac/differential/csaw/newrun_22112024/E175vsE135/macs2_tmm')
####Let's annotate the peaks#############
## loading packages
library(ChIPseeker)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
peakAnno <- annotatePeak(final.merged.peaks, tssRegion=c(-3000, 3000),
                         TxDb=txdb, annoDb="org.Mm.eg.db")
annot <- data.frame(peakAnno@anno)		
write.table(annot, "E175_vs_E135_csaw_DA-windows_macs2_tmm_all_annotated.txt", sep="\t", quote=F, col.names=T, row.names=F)	
write.csv(annot, "E175_vs_E135_csaw_DA-windows_macs2_tmm_all_annotated.csv", quote=F, col.names=T, row.names=F)			 
```

```{r}
#########Below is Epi vs EPDC differential analysis################
library(GenomicRanges)
library(csaw)
library(BiocParallel)
```

```{r}
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project/macs2')
# starting from MACS2, filtered consensus peaks across all conditions (which I generated using the Corces et al. approach, over all three timepoints, generated from bam files of merged replicates <- it may be better to merge replicates from bam level rather than peak level)

all.peaks <- read.table("epi_mes_merged.filtered.bed", sep="\t")[,1:3]
colnames(all.peaks) <- c("chrom", "start", "end")
all.peaks <- GRanges(all.peaks)
start(all.peaks) <- start(all.peaks) + 1
```

```{r}
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project')

pe.bams <- c("/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library/E135_REP1.mLb.clN.sorted.bam",
             "/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library/E135_REP2.mLb.clN.sorted.bam",
             "/mnt/sdb/andiar/data_output_EPI_ATAC_E115E135E175/bowtie2/merged_library/E135_REP3.mLb.clN.sorted.bam",
		     "EPDC_E13.sorted.bam", "EPDC_mergedfromR1R2.sorted.bam","EPDC_E125.sorted.bam")

# read mm10 blacklist
blacklist <- read.table("/mnt/sdb/qdang/reference/mouse/mm10-blacklist.v2.bed", sep="\t")
colnames(blacklist) <- c("chrom", "start", "end")
blacklist <- GRanges(blacklist)
start(blacklist) <- start(blacklist)+1.

# define read parameters
standard.chr <- paste0("chr", c(1:19, "X", "Y")) # only use standard chromosomes
param <- readParam(max.frag=1000, pe="both", discard=blacklist, restrict=standard.chr)
```

```{r}
##############################
bioc_param <- MulticoreParam(workers = 25)
# count reads in windows specified by MACS2                                      
peak.counts <- regionCounts(pe.bams, all.peaks, param=param, BPPARAM=bioc_param)

##############################
# MACS2 peaks only: filter low abundance peaks
library("edgeR")
peak.abundances <- aveLogCPM(asDGEList(peak.counts)) 
peak.counts.filt <- peak.counts[peak.abundances > -3, ] # only use peaks logCPM > -3
# few or no peaks should be removed; modify as desired
```

```{r}
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project')
##############################
# count BAM reads in, e.g. 300 bp windows
counts <- windowCounts(pe.bams, width=300, param=param, BPPARAM=bioc_param) # set width as desired from the fragment length distribution analyses

# filter uninteresting features (windows) by local enrichment
# local background estimator: 2kb neighborhood
neighbor <- suppressWarnings(resize(rowRanges(counts), width=2000, fix="center")) # change width parameter as desired
wider <- regionCounts(pe.bams, regions=neighbor, param=param) # count reads in neighborhoods
filter.stat <- filterWindowsLocal(counts, wider) 
counts.local.filt <- counts[filter.stat$filter > log2(3),] # threshold of 3-fold increase in enrichment over 2kb neighborhood abundance; change as desired
```

```{r}
###############################
# count BAM background bins (for TMM normalization)
binned <- windowCounts(pe.bams, bin=TRUE, width=10000, param=param, BPPARAM=bioc_param)

```{r}
##########################################
# NORMALIZATION (Loess normalization implementation has changed in csaw 1.20.0)

# method 1: MACS2 peaks only, TMM normalization based on binned counts
peak.counts.tmm <- peak.counts.filt
peak.counts.tmm <- normFactors(binned, se.out=peak.counts.tmm)

# method 2: MACS2 peaks only, csaw loess-normalization
peak.counts.loess <- peak.counts.filt
peak.counts.loess <- normOffsets(peak.counts.loess, se.out=TRUE) # type="loess" is now default
# from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."

# method 3: csaw de novo peaks by local enrichment, TMM normalization based on binned counts
counts.local.tmm <- counts.local.filt
counts.local.tmm <- normFactors(binned, se.out=counts.local.tmm)

# method 4: csaw de novo peaks by local enrichment, csaw loess-normalization
counts.local.loess <- counts.local.filt
counts.local.loess <- normOffsets(counts.local.loess, se.out=TRUE) # type="loess" is now default
# from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."
```
```

```{r}
#########################################
# DIFFERENTIAL ACCESSIBILITY ANALYSIS

#working.windows <- peak.counts.tmm # MACS2 peaks only, standard TMM normalization based on binned counts
#working.windows <- peak.counts.loess # MACS2 peaks only, for trended biases
working.windows <- counts.local.tmm # csaw de novo peaks by local enrichment, standard TMM normalization based on binned counts
#working.windows <- counts.local.loess # csaw de novo peaks by local enrichment, for trended biases
# SEE THE CSAW MANUAL FOR MORE INFO ON NORMALIZATION METHODS
```

```{r}
#set working directory
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project/differential_csaw/denovo_tmm')
# setup design matrix
# see edgeR manual for more information
y <- asDGEList(working.windows)
colnames(y$counts) <- c("E135_REP1", "E135_REP2", "E135_REP3", "EPDC_E13", "EPDC_mergedfromR1R2", "EPDC_E125")
rownames(y$samples) <- c("E135_REP1", "E135_REP2", "E135_REP3", "EPDC_E13", "EPDC_mergedfromR1R2", "EPDC_E125")
y$samples$group <- c("EPI", "EPI","EPI", "EPDC", "EPDC","EPDC")
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- c("EPI", "EPDC")
# design

# stabilize dispersion estimates with empirical bayes
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)

# testing for differentially-accessible windows
results <- glmQLFTest(fit, contrast=makeContrasts(EPDC-EPI, levels=design))
# head(results$table)

# combine GRanges rowdata with DA statistics
rowData(working.windows) <- cbind(rowData(working.windows), results$table)
working.windows@rowRanges

# merge nearby windows
# up to "tol" distance apart: 500 bp in this case
# max merged window width: 5000 bp
merged.peaks <- mergeWindows(rowRanges(working.windows), tol=500L, max.width=5000L)
# summary(width(merged.peaks$region))
# should merge some peaks; change as desired

# use most significant window as statistical representation for p-value and FDR for merged windows
tab.best <- getBestTest(merged.peaks$id, results$table, pval.col='PValue',cpm.col='logCPM')
head(tab.best)
# combine merged peaks window range with statistics

final.merged.peaks <- GRanges(cbind(as.data.frame(merged.peaks$region), results$table[tab.best$rep.test, -4], tab.best[,-c(7:8)]))

# sort by FDR
final.merged.peaks <- final.merged.peaks[order(final.merged.peaks@elementMetadata$FDR), ]
final.merged.peaks

# filter by FDR threshold
FDR.thresh <- 0.05 # set as desired
final.merged.peaks.sig <- final.merged.peaks[final.merged.peaks@elementMetadata$FDR < FDR.thresh, ]
final.merged.peaks.sig # significant differentially-accessible windows

write.table(final.merged.peaks, "EPDC_vs_EPI_csaw_DA-windows_denovo_tmm_tmm_all.txt", sep="\t", quote=F, col.names=T, row.names=F)
write.table(final.merged.peaks.sig, "EPDC_vs_EPI_csaw_DA-windows_denovo_tmm_significant.txt", sep="\t", quote=F, col.names=T, row.names=F)

###########################################
```

```{r}
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project/differential_csaw/denovo_tmm')
# Generate MA plot
library(ggplot2)

final.merged.peaks$sig <- "n.s."
final.merged.peaks$sig[final.merged.peaks$FDR < FDR.thresh] <- "significant"

plot <- ggplot(data=data.frame(final.merged.peaks),
       aes(x = logCPM, y = logFC, col = factor(sig, levels=c("n.s.", "significant")))) + 
  geom_point() + scale_color_manual(values = c("black", "red")) + 
  geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + # smoothed loess fit; can add span=0.5 to reduce computation load/time
  geom_hline(yintercept = 0) + labs(col = NULL)

ggsave(plot, filename = "EPDC_vs_EPI_csaw_MAplot_denovo_tmm.png", width = 6, height = 6, dpi = 300)
```

```{r}
setwd('/mnt/sdb/qdang/wt1_project/epi_mes_project/differential_csaw/denovo_tmm')
####Let's annotate the peaks#############
## loading packages
library(ChIPseeker)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
peakAnno <- annotatePeak(final.merged.peaks, tssRegion=c(-3000, 3000),
                         TxDb=txdb, annoDb="org.Mm.eg.db")
annot <- data.frame(peakAnno@anno)		
#write.table(annot, "EPDC_vs_EPI_csaw_DA-windows_macs2_tmm_all_annotated.txt", sep="\t", quote=F, col.names=T, row.names=F)	
write.csv(annot, "EPDC_vs_EPI_csaw_DA-windows_denovo_tmm_all_annotated.csv", quote=F, col.names=T, row.names=F)			 
```